package gocms

import (
	"errors"
	"fmt"
	"strings"

	"github.com/goliatone/go-notifications/pkg/domain"
	"github.com/goliatone/go-notifications/pkg/templates"
)

// TemplateSourceType identifies TemplateSource.Type values generated by this package.
const TemplateSourceType = "gocms-block"

var (
	// ErrCodeRequired indicates the consumer did not provide a template code.
	ErrCodeRequired = errors.New("gocms: template code is required")
	// ErrChannelRequired indicates the consumer did not provide a template channel.
	ErrChannelRequired = errors.New("gocms: template channel is required")
	// ErrNoTranslations signals that a snapshot did not include any locale payloads.
	ErrNoTranslations = errors.New("gocms: snapshot did not include translations")
	// ErrLocaleIdentifierMissing indicates a translation entry did not specify a locale identifier.
	ErrLocaleIdentifierMissing = errors.New("gocms: locale identifier is required")
)

// LocaleResolver maps the opaque go-cms locale identifier in a snapshot to
// the locale string stored alongside notification templates.
type LocaleResolver func(raw string) (string, error)

// FieldMapping allows callers to customize which keys inside the go-cms
// translation payload map subject/body/preheader/blocks.
type FieldMapping struct {
	Subject   string
	Body      string
	Preheader string
	Blocks    string

	initialized bool
}

func (m FieldMapping) withDefaults() FieldMapping {
	if m.initialized {
		return m
	}
	if strings.TrimSpace(m.Subject) == "" {
		m.Subject = "subject"
	}
	if strings.TrimSpace(m.Body) == "" {
		m.Body = "body"
	}
	if strings.TrimSpace(m.Preheader) == "" {
		m.Preheader = "preheader"
	}
	if strings.TrimSpace(m.Blocks) == "" {
		m.Blocks = "blocks"
	}
	m.initialized = true
	return m
}

// TemplateSpec captures the invariant fields applied to every template variant produced
// from a go-cms snapshot (template code, channel, schema metadata, etc.).
type TemplateSpec struct {
	Code            string
	Channel         string
	Format          string
	Description     string
	SourceReference string
	Schema          domain.TemplateSchema
	Metadata        domain.JSONMap
	Fields          FieldMapping
	ResolveLocale   LocaleResolver
}

func (s TemplateSpec) normalized() (TemplateSpec, error) {
	s.Code = strings.TrimSpace(s.Code)
	s.Channel = strings.TrimSpace(s.Channel)
	if s.Code == "" {
		return TemplateSpec{}, ErrCodeRequired
	}
	if s.Channel == "" {
		return TemplateSpec{}, ErrChannelRequired
	}
	if strings.TrimSpace(s.Format) == "" {
		s.Format = "text/html"
	}
	s.Fields = s.Fields.withDefaults()
	if s.ResolveLocale == nil {
		s.ResolveLocale = func(raw string) (string, error) {
			raw = strings.TrimSpace(raw)
			if raw == "" {
				return "", ErrLocaleIdentifierMissing
			}
			return raw, nil
		}
	}
	return s, nil
}

type translationPayload struct {
	locale        string
	content       map[string]any
	overrides     map[string]any
	configuration map[string]any
	metadata      map[string]any
}

func buildTemplateInput(spec TemplateSpec, payload translationPayload) (templates.TemplateInput, error) {
	locale, err := spec.ResolveLocale(payload.locale)
	if err != nil {
		return templates.TemplateInput{}, fmt.Errorf("gocms: resolve locale %q: %w", payload.locale, err)
	}
	if strings.TrimSpace(locale) == "" {
		return templates.TemplateInput{}, fmt.Errorf("gocms: resolve locale %q: %w", payload.locale, ErrLocaleIdentifierMissing)
	}

	srcPayload := newSourcePayload(payload, spec.Fields)

	return templates.TemplateInput{
		Code:        spec.Code,
		Channel:     spec.Channel,
		Locale:      locale,
		Format:      spec.Format,
		Description: spec.Description,
		Schema:      spec.Schema,
		Metadata:    cloneJSONMap(spec.Metadata),
		Source: domain.TemplateSource{
			Type:      TemplateSourceType,
			Reference: strings.TrimSpace(spec.SourceReference),
			Payload:   srcPayload,
		},
	}, nil
}

func newSourcePayload(payload translationPayload, fields FieldMapping) domain.JSONMap {
	var out domain.JSONMap

	setString := func(value string, key string) {
		if value == "" {
			return
		}
		if out == nil {
			out = make(domain.JSONMap)
		}
		out[key] = value
	}

	setBlocks := func(blocks []any) {
		if len(blocks) == 0 {
			return
		}
		if out == nil {
			out = make(domain.JSONMap)
		}
		out["blocks"] = blocks
	}

	addMap := func(key string, data map[string]any) {
		if len(data) == 0 {
			return
		}
		if out == nil {
			out = make(domain.JSONMap)
		}
		out[key] = cloneMap(data)
	}

	if subject := firstString(payload.overrides, fields.Subject); subject != "" {
		setString(subject, "subject")
	} else if subject := firstString(payload.content, fields.Subject); subject != "" {
		setString(subject, "subject")
	}

	if body := firstString(payload.overrides, fields.Body); body != "" {
		setString(body, "body")
	} else if body := firstString(payload.content, fields.Body); body != "" {
		setString(body, "body")
	}

	if preheader := firstString(payload.overrides, fields.Preheader); preheader != "" {
		setString(preheader, "preheader")
	} else if preheader := firstString(payload.content, fields.Preheader); preheader != "" {
		setString(preheader, "preheader")
	}

	if blocks := firstBlocks(payload.overrides, fields.Blocks); len(blocks) > 0 {
		setBlocks(blocks)
	} else if blocks := firstBlocks(payload.content, fields.Blocks); len(blocks) > 0 {
		setBlocks(blocks)
	}

	addMap("content", payload.content)
	addMap("attribute_overrides", payload.overrides)
	addMap("configuration", payload.configuration)
	addMap("metadata", payload.metadata)

	return out
}
